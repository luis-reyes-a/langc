These are the basic types a user can define

TypeSpec_Internal;
TypeSpec_StructUnion; 
TypeSpec_Enum; //and enum flags
TypeSpec_Ptr;
TypeSpec_Array;
TypeSpec_Proc;

Whenever the language attempts to parse a type it checks to see if that type has been
"declared" yet. If the type hasn't been declared I still allocate a type for that 
type, mark it as "undeclared" and resolve it later.

Later when declaring the type (whenever AddType() is called...) I look for an undeclared type by that name and update it in accordance to how it's declared.

This, however, will NOT FIX DECL ORDERING. I still need to do myself after the parse


Two main cases for out of order decls:
1) Type of declared variable before the type declaration
2) Expression uses an identifier before it was decalred


So far the decl_list is behaving like a scope. It stores all declared decls in a scope. It is passed in to ParseStatement so when it generate a scope for a compound stmt it points to the *above scope when searching

while(WillEatTokenType(lexer, TokenType_Identifier)){
	//...
}
else{
	//...
}

=>
{
	bool32 FirstCheck = WillEat();
	if(FirstCheck){
		while(FirstCheck || WillEat()){
			//NOTE short-circuiting prevents WillEat from 
			// being called twice on first pass
			FirstCheck = false;
		}
	}
	else{
		//..do whatever
	}
}


Execution order
// () parenthetical
// calls, arrays, numbers, literals, identifiers
// * & + ! 
// * / %
// + -
// << >>
// < > <= >= == != 
// && 
// ||
// ternary
// assignment
// compound

flags Flags;
if(Flag.Has(Red, Green, Blue)) // Flag & Green || Flag & Blue || Flag & Red
Flags.Set(Blue); //sets bit field to 1
Flags.Clr()      //sets bit field to 0
Flags.Neg()      //negates bit field, two's complement?
Flags.Has()      //true if has all bit fields  (F & b) && (F & c) && (F & d)
Flags.One()      //true if one bifield is set  (F & b) || (F & c) || (f & d)  
Flags.SetCount() //how many bitfields are set


structs can only have constants, variables, and unammed structs

struct my_struct{
	let const_identifier = 3.14;
	u32 var = 0, var2;
	struct{
		let PI = 3.1415;
	}
}