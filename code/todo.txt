sizeof(*ptr)

call(*ptr, )

enum_flags flags{
        Red,
        Green,
        Blue,
};

flags Flags;
Flags.Set(Red, Green);

//NOTE this will have to work on any integral type!
if(Flag.Has(Red, Green, Blue)) // Flag & Green || Flag & Blue || Flag & Red
Flags.Set(Blue); //sets bit field to 1
Flags.Clr()      //sets bit field to 0
Flags.Neg()      //negates bit field, two's complement?
Flags.Has()      //true if has all bit fields  (F & b) && (F & c) && (F & d)
Flags.One()      //true if one bifield is set  (F & b) || (F & c) || (f & d)  
Flags.SetCount() //how many bitfields are set


// () parenthetical
// calls, arrays, numbers, literals, identifiers
// * & + ! 
// * / %
// + -
// << >>
// < > <= >= == != 
// && 
// ||

struct {
    
    
} my_only_struct;

if a < b == b > c;
if a && b || c && d

// ternary
// assignment
// compound

bool is_odd = if(a % 3 == 0) true else false;
bool is_even = if a % 2 == 0 then true else false;

if token.type == TokenType_Keyword
{
    
}
else if token.type == TokenType_Const
{
    
}

for u32 i = 0; i < 10; ++i
{
    
}

u32 array[10]

for i in 0..ArrayCount(array)-1

for u32 *elem in array
{
    
}

enum_flags my_flags
{
    Flag1,//(1 << 0)
        Flag2,//(1 << 1)
        Flag3,//(1 << 2)
        Flag4,//(1 << 3)
};

my_flags flags = Flag1;



if x < 10 then
do_this();
else
do_this_two();
